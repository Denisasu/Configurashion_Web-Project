<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Рекомендация: Проектирование объектов EJB </title>
<meta content="Guideline" name="uma.type">
<meta content="designing_enterprise_javabeans_ejbs" name="uma.name">
<meta content="Проектирование объектов EJB " name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "2.8082009592332426E-306"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="2.8082009592332426E-306"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Рекомендация: Проектирование объектов EJB </td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">В этом разделе рассматривается проектирование объектов EJB для приложения J2EE. </td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/tasks/class_design_98F20FF9.html" guid="{27AE0601-2E95-4A6A-8EB3-0A4BA8E5626B}">Проектирование классов</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a> 
<h3>
    <a id="Introduction" name="Introduction"></a>Введение
</h3>
<p>
    Этот раздел посвящен проектированию объектов EJB. Дополнительная информация об объектах EJB, в частности, указания по
    их идентификации и моделированию, приведена в разделе <a class="elementLinkWithUserText" href="./../../../tech.j2ee/guidances/guidelines/enterprise_javabean_ejb_7F0C3AFF.html" guid="1.5078998518719443E-305">Указания для рабочего продукта: объекты EJB</a>.
</p>
<p>
    В следующих разделах приведены конкретные указания по проектированию конкретных типов объектов EJB:
</p>
<ul type="disc">
    <li>
        <a class="elementLinkWithUserText" href="./../../../tech.j2ee/guidances/guidelines/designing_session_beans_BDBA5DEB.html" guid="5.207478815358005E-306">Проектирование сеансовых объектов EJB</a>
    </li>
    <li>
        <a class="elementLinkWithUserText" href="./../../../tech.j2ee/guidances/guidelines/designing_entity_beans_7CD45D28.html" guid="5.953653009453999E-307">Проектирование сущностных объектов EJB</a>
    </li>
    <li>
        <a class="elementLinkWithUserText" href="./../../../tech.j2ee/guidances/guidelines/designing_message-driven_beans_DE3F4EC4.html" guid="7.497484412493539E-306">Проектирование управляемых сообщениями объектов EJB</a>
    </li>
</ul>
<h3>
    <a id="Local" name="Local">Сравнение локальных и удаленных интерфейсов</a>
</h3>
<p>
    Локальные и удаленные интерфейсы описаны в разделе <a class="elementLinkWithUserText" href="./../../../tech.j2ee/guidances/concepts/java_2_platform_enterprise_edition_j2ee_overview_9A95BA45.html#Enterprise_JavaBeans" guid="1.527482214591853E-307">Концепция: обзор J2EE: объекты EJB</a>.
</p>
<p>
    Локальные интерфейсы эффективнее удаленных. Локальные интерфейсы необходимы, если есть конкретные клиенты, которые
    всегда являются локальными относительно EJB.
</p>
<p>
    Более подробные сведения по этой теме приведены в указаниях по конкретным типам объектов EJB.
</p>
<h3>
    <a id="Parameter" name="Parameter"></a>Передача параметров
</h3>
<p>
    Существенное влияние на производительность оказывают число удаленных вызовов и объем данных, передаваемых в каждом
    вызове. Одно из средств решения этой проблемы заключается в применении специальных вызовов, возвращающих все
    необходимые удаленному клиенту данные. Например, сеансовый объект EJB, выступающий в качестве фасада для набора
    связанных сущностных объектов EJB, может копировать данные из нескольких сущностных объектов EJB в сериализуемые
    объекты значений и возвращать эти данные за один удаленный вызов. Подробное описание приведено в параграфе <i>Базовые
    шаблоны J2EE - шаблон объектов значений</i> ([<a class="elementLinkWithUserText" href="./../../../tech.j2ee/guidances/supportingmaterials/java_references_110189E3.html#ALU01" guid="1.4494927535802764E-304">ALU01</a>].
</p>
<p>
    С другой стороны, необходимо следить за тем, чтобы интерфейсы носили как можно более общий характер, и избегать
    отправки слишком больших объемов ненужных данных.
</p>
<h3>
    <a id="Transactions" name="Transactions">Транзакции</a>
</h3>
<p>
    Демаркация транзакций - это их инициализация, фиксация и прерывание. Проектировщик объектов EJB должен решить, какую
    демаркацию транзакций он будет реализовывать: управляемую объектами EJB или управляемую контейнером. Вы должны выбрать
    расположения границ транзакций в последовательностях операторов бизнес-логики, выполняемых приложением. Дополнительная
    информация приведена в разделе <a class="elementLinkWithUserText" href="./../../../core.base_rup/tasks/use_case_design_92D13EEE.html#Modeling Transactions" guid="{76E2B93D-051C-4B8C-BEA1-B40A40CBD986}">Задача: проектирование Use-Case, моделирование транзакций</a> и в
    параграфе <i>Управление транзакциями</i> раздела <a class="elementLinkWithUserText" href="./../../../tech.j2ee/guidances/concepts/java_2_platform_enterprise_edition_j2ee_overview_9A95BA45.html" guid="1.527482214591853E-307">Концепция: обзор J2EE</a>.
</p>
<p>
    Применяйте транзакции, управляемые контейнером, везде, где это возможно. Это упрощает код и позволяет разработчикам
    сконцентрироваться на бизнес-логике приложения.
</p>
<p>
    Как правило, чем ниже уровень детализации транзакций, тем выше общая производительность. Предположим, что вы
    отправляете последовательность вызовов методов для объекта EJB (например, getX, getY и setZ). По умолчанию каждый метод
    выполняется в новой транзакции, что снижает производительность. Для того чтобы вызвать все методы в одной и той же
    транзакции, создайте другой метод, например метод processXYZ сеансового объекта EJB, и задайте атрибуты транзакции
    вызываемых методов равными значению <i>Required</i>, так чтобы они использовали существующую транзакцию (например,
    транзакцию вызывающего метода в сеансовом объекте EJB). &nbsp;
</p>
<h3>
    <a id="Security" name="Security">Защита</a>
</h3>
<p>
    Основные концепции защиты EJB рассмотрены в разделе <a class="elementLinkWithUserText" href="./../../../tech.j2ee/guidances/concepts/java_2_platform_enterprise_edition_j2ee_overview_9A95BA45.html#Security" guid="1.527482214591853E-307">Концепция: обзор платформы J2EE - защита</a>.
</p>
<p>
    Требования к защите EJB задаются путем определения <i>ролей защиты</i> и <i>прав доступа методов</i>. Роли&nbsp;защиты
    и права доступа методов определяются в файле описания EJB. Отображение&nbsp;ролей защиты в конкретных пользователей или
    группы пользователей выполняется сервером (с помощью административных инструментов).&nbsp;
</p>
<p>
    Роль защиты определяет набор схожих типов операций, группируемых под одним именем. Права доступа метода предоставляют
    конкретной роли защиты право вызывать метод. Например,&nbsp;рассмотрим сущностный объект EJB <i>Сотрудник</i> с
    методами <i>setAddress</i>, <i>setSalary</i> и т.п. Роли защиты <i>Руководитель</i> могут быть предоставлены права
    доступа к методам setAddress и setSalary, а роли защиты <i>Сотрудник</i> - только права доступа к методу
    setAddress.&nbsp;&nbsp;
</p>
<p>
    В некоторых ситуациях обеспечивать соблюдение требований к защите приложения, используя декларативные права доступа
    методов из файла описания, невозможно. В таких случаях следует воспользоваться методами getCallerPrincipal и
    isCallerInRole интерфейса javax.ejb.EJBContext. &nbsp;
</p>
<h3>
    <a id="Timer_Service" name="Timer_Service">Служба таймеров</a>
</h3>
<p>
    Начиная с версии J2EE 1.4 (точнее, EJB 2.1), сеансовые объекты EJB, не сохраняющие состояние, и управляемые сообщениями
    объекты EJB могут применять таймеры и планировать пакетные процессы с помощью службы таймеров EJB.
</p>
<p>
    Служба таймеров EJB предоставляет методы, позволяющие планировать обратные вызовы для событий, основанных на времени.
    Контейнер предоставляет надежную и поддерживающую транзакции службу уведомлений для таких событий. Выдачу уведомлений
    таймера можно запланировать так, чтобы она происходила в заданное время, через заданный промежуток или периодически с
    заданным периодом.
</p>
<p>
    Служба таймеров реализуется контейнером EJB. Объект EJB получает доступ к этой службе через интерфейс EJBContext.
</p>
<p>
    Служба таймеров EJB представляет собой довольно грубый инструмент уведомления, предназначенный для использования в
    моделировании процессов уровня приложения, но не событий в режиме реального времени.
</p>
<h3>
    <a id="Direct_Access_vs._Entity_EJBs" name="Direct_Access_vs._Entity_EJBs"></a>Сравнение прямого доступа и объектов EJB
</h3>
<p>
    Применение сущностных объектов EJB для работы с постоянными данными обеспечивает стандартный, функционально богатый
    механизм доступа к постоянным данным. Выбор между применением постоянного хранения, управляемого EJB, и постоянного
    хранения, управляемого контейнером, может быть скрыт от клиентов, что придает проекту некоторую гибкость. Объекты EJB
    могут воспользоваться транзакциями, управлением ресурсами, распределением нагрузки и другими функциями,
    предоставляемыми средой J2EE.
</p>
<p>
    Однако в некоторых случаях может потребоваться прямой доступ к базе данных без использования сущностных объектов EJB.
    Например, если данные всегда запрашиваются только для чтения, причем одним и тем же клиентом, то прямой доступ к базе
    данных будет эффективнее.
</p>
<p>
    Если вы обращаетесь к базе данных напрямую (например, из сеансового объекта EJB без сохранения состояния),
    инкапсулируйте весь доступ к базе данных в классе Data Access Object. Это обычный класс Java, скрывающий и
    инкапсулирующий базовый механизм хранения и изолирующий изменения при модификации интерфейса источника данных. См.
    параграф <i>Базовые шаблоны J2EE - шаблон объектов доступа к данным</i> ([<a class="elementLinkWithUserText" href="./../../../tech.j2ee/guidances/supportingmaterials/java_references_110189E3.html#ALU01" guid="1.4494927535802764E-304">ALU01</a>].
</p>
<h3>
    <a id="Database_Connections" name="Database_Connections">Соединения с базами данных</a>
</h3>
<p>
    В сущности, все контейнеры EJB поддерживают общий пул соединений, совместно используя набор уже созданных соединений
    между клиентами. Эти соединения назначаются объектам EJB по мере необходимости. Благодаря этому объект EJB получает
    соединение без затрат на его создание и инициализацию. После возврата соединения в пул оно используется вновь. Размер
    пула должен быть достаточным для поддержания такой системы повторного использования соединений.
</p>
<p>
    В случае сущностных объектов EJB с постоянным хранением, управляемым контейнером, соединениями с базами данных и
    доступом к пулу таких соединений управляет контейнер.
</p>
<p>
    В случае сущностных объектов EJB с постоянным хранением, управляемым EJB (а также сеансовых или управляемых сообщениями
    объектов EJB, обращающихся к базе данных), за кодирование процедуры соединения отвечает разработчик. Выполните
    следующие инструкции:
</p>
<ul>
    <li>
        Изолируйте код доступа к базе данных в классе DAO.
    </li>
    <li>
        Не вносите в код фактический URL базы данных. Вместо этого, укажите логическое имя, которое можно извлекать с
        помощью функции поиска JNDI. Это позволит использовать объект EJB во многих приложениях, возможно с различными
        именами баз данных.
    </li>
    <li>
        В общем случае, применяйте пулы соединений и удерживайте соединение ровно столько времени, сколько необходимо.
        Например, сущностный объект EJB может подключиться, обновить строку в таблице и отключиться. Это позволит различным
        объектам EJB совместно работать с одним и тем же соединением. Спецификация JDBC предусматривает поддержку пулов
        соединений.
    </li>
</ul></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
