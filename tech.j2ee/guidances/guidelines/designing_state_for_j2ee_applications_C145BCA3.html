<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Рекомендация:  Состояние проектирования для приложений J2EE </title>
<meta content="Guideline" name="uma.type">
<meta content="designing_state_for_j2ee_applications" name="uma.name">
<meta content=" Состояние проектирования для приложений J2EE " name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "7.896195949843941E-306"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="7.896195949843941E-306"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Рекомендация:  Состояние проектирования для приложений J2EE </td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">В этом руководстве обсуждаются механизмы схемы управления состояниями для приложения J2EE.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/tasks/architectural_analysis_2B9BE03.html" guid="{8CB48402-D4C5-4E17-BB33-507315CB1BBF}">Архитектурный анализ</a>
</li>
<li>
<a href="./../../../core.base_rup/tasks/identify_design_mechanisms_9A197FBC.html" guid="{C7A26BD7-3820-48D9-830F-684C3AF155F9}">Определение механизмов проектирования</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><h3>
    Введение
</h3>
<p>
    Эффективное управление состояниями приложения - это важный аспект проектирования распределенных приложений. В этом
    руководстве дается обзор некоторых общих замечаний о проектировании и механизмов управления состояниями приложения
    J2EE.
</p>
<p>
    Замечания о проектировании, связанные с управлением состояниями, относятся к Этапу разработки проекта. &nbsp;
    Разработчик программного обеспечения должен изучить общие подходы к управлению состояниями в процессе Анализа &
    Обучения проектированию <u><a href="./../../../core.base_rup/capabilitypatterns/define_a_candidate_architecture_A3651DA3.html" guid="{71ADFE9A-34A0-41BD-8A17-BEA3210E2BBD}" class="elementLinkWithUserText">Действие: Определить архитектуру
    кандидата</a></u>.&nbsp; При выполнении <u><a href="./../../../core.base_rup/tasks/architectural_analysis_2B9BE03.html" guid="{8CB48402-D4C5-4E17-BB33-507315CB1BBF}" class="elementLinkWithUserText">Задача: Анализ архитектуры</a></u>,
    разработчик программного обеспечения должен изучить требования к масштабируемости и производительности приложения,
    чтобы определить, какие приемы управления состояниями необходимо использовать в приложении для их удовлетворения.
    &nbsp; На Этапе разработки проект приложения усовершенствуется, и разработчик должен определить характерные для
    &nbsp;J2EE механизмы реализации управления информацией о состоянии приложения в <a href="./../../../core.base_rup/tasks/identify_design_mechanisms_9A197FBC.html" guid="{C7A26BD7-3820-48D9-830F-684C3AF155F9}" class="elementLinkWithUserText">Задача: Идентификация механизмов проекта</a>.
</p>
<p>
    Как описано в <a href="./../../../tech.j2ee/guidances/concepts/j2ee_deployment_configurations_C0F819AF.html" guid="7.671163061311939E-306" class="elementLinkWithUserText">Концепция: Конфигурации развертывания J2EE</a>,
    приложения J2EE могут быть составлены из нескольких логических уровней, распределенных среди одного или нескольких
    уровней (систем).&nbsp; После краткого технического обзора управления состояниями, остальные разделы этого руководства
    посвящены обсуждению различных механизмов реализации и схем управления состояниями, которые могут быть использованы на
    нескольких уровнях приложения.
</p>
<p>
    Заметьте, что разработчик программного обеспечения должен документировать, какие механизмы были выбраны, в процессе
    выполнения <a href="./../../../core.base_rup/workproducts/rup_software_architecture_document_C367485C.html" guid="{6F49641A-ED10-47B5-9E5D-3F90A6BF3006}" class="elementLinkWithUserText">Рабочий продукт: Документация по
    архитектуре программного обеспечения</a>, а также должен предоставить рекомендации по применению этих механизмов в
    составе руководства по проекту.
</p>
<h3>
    <a name="Topic 1" id="Topic 1"></a>Технический обзор
</h3>
<p>
    Существует нарастающая тенденция к построению распределенных приложений, которые взаимодействуют через Интернет в той
    или иной форме. Даже хотя &nbsp;по своей природе Интернет не поддерживает сохранение состояний, существует потребность
    управлять состояниями для построения любого рода бизнес-приложений. Рассмотрим Интернет-приложение, в котором &nbsp;
    пользователь щелкает на ссылке со страницы А на страницу Б. Приложение, которое обрабатывает запрос страницы Б, не
    имеет доступа к информации, использованной для обработки страницы А. &nbsp; Такое поведение применимо для статических
    Web-страниц, но большинство бизнес-приложений требуют информации о предыдущей обработке. В такой ситуации используются
    механизмы управления состояниями, предоставленные J2EE.
</p>
<h4>
    <a name="Topic 1a" id="Topic 1a"></a>Временное и постоянное состояние
</h4>
<p>
    Перед углублением в руководство по управлению состояниями важно разобраться в различиях между типами информации о
    состоянии. Информация о состоянии может быть в общих чертах разделена на две категории: временная&nbsp;(существует
    только пока приложение активно) и постоянная (существует после завершения приложения).
</p>
<p>
    Временная информация о состоянии существует, пока некоторая сущность сохраняет ее. Например, информация о состоянии,
    сохраненная как поле в обычном классе Java. Когда контейнер этого класса по каким-либо причинам завершает свою работу,
    информация о состоянии теряется, если данные не были продублированы где-то еще, например, на резервном сервере.
</p>
<p>
    Постоянное состояние существует, пока существует хранилище данных, используемое для хранения информации о состоянии.
    &nbsp; Постоянная информация о состоянии обычно сохраняется в файле или базе данных, и она загружается приложением по
    мере необходимости. &nbsp; Любые изменения постоянной информации о состоянии должны записываться в базу данных. &nbsp;
    Аспекты целостности и восстанавливаемости постоянного хранилища данных должны быть согласованы с теми данными, к
    которым имеет доступ приложение. Примером постоянного состояния является информация, сохраненная в хранилище данных,
    таком как реляционная база данных.
</p>
<h4>
    Состояние сеанса
</h4>
<p>
    Клиентам Web часто требуется иметь возможность делать множественные запросы браузера при переходе от страницы к
    странице, сохраняя информацию о клиенте, такую как выбранные товары в корзине. Web-приложения управляют этим, создавая
    ИД сеанса и связывая с ним данные о состоянии. ИД сеанса и связанные с ним данные называются состоянием сеанса.
</p>
<p>
    Состояние сеанса - это данные, связанные с определенным взаимодействием клиента и web-приложения за короткий период
    времени (минуты или часы, но не дни). Таким образом, состояние сеанса - это кратковременные данные, которые обычно
    удаляются после некоторого периода тайм-аута для освобождения ресурсов.
</p>
<p>
    Состояние сеанса можно сохранить на клиенте или на сервере, как описано в следующих разделах. Платформа J2EE
    предоставляет механизмы, специально предназначенные для управления состояниями сеанса, по причине их важности в
    web-приложениях.
</p>
<h3>
    Основные механизмы хранилища
</h3>
<p>
    Ниже приведены основные механизмы, используемые в web-приложениях для сохранения состояний.
</p>
<h4>
    <a name="Topic 2a" id="Topic 2a"></a>Cookies
</h4>
<p>
    Cookies - это маленькие текстовые файлы, хранящиеся на web-клиентах. Сервер может сохранять cookie на клиенте.
    Последующие запросы клиента отправляют cookie на сервер, предоставляя серверу доступ к данным состояния, хранящимся в
    cookie.
</p>
<p>
    Некоторые проблемы применения cookie:
</p>
<ul>
    <li>
        Многие пользователи считают, что cookie ослабляют защиту и/или конфиденциальность, и поэтому они выключают cookie.
    </li>
    <li>
        Существуют ограничения на размер заголовков cookie, и это ограничивает объем данных, который может быть сохранен.
    </li>
    <li>
        Некоторые протоколы, такие как Протокол беспроводного доступа (WAP) не поддерживают cookies.
    </li>
    <li>
        Если клиент входит в систему из другого расположения (например, из другой системы), то сохраненные cookie
        становятся недоступны.
    </li>
    <li>
        Данные о состоянии должны быть представимы строковыми значениями.
    </li>
</ul>
<h4>
    <a name="Topic 2a1" id="Topic 2a1"></a>Преобразование URL
</h4>
<p>
    Преобразование URL - это механизм для вложения состояния сеанса в URL, указанные на каждой странице. Когда Web-сервер
    генерирует страницы, которые должны быть доставлены клиенту, он кодирует состояние сеанса в URL страниц. Затем, когда
    пользователь щелкает на URL, данные о состоянии, сохраненные в URL, отправляются назад на сервер, позволяя ему повторно
    установить контекст сеанса. Аналогичный механизм использует скрытые поля HTML. Существуют следующие проблемы при
    использовании этих механизмов:
</p>
<ul>
    <li>
        Все страницы в данном сеансе должны управляться сервером, в противном случае, сервер может потерять цепь сеанса.
    </li>
    <li>
        Состояние не сохраняется, когда клиент закрывает свой браузер или вводит определенный URL вручную или с помощью
        закладки.
    </li>
    <li>
        Как и в случае с cookie, данные о состоянии не доступны, когда клиент входит в систему из другого расположения.
    </li>
    <li>
        Как и в случае с cookie, данные о состоянии должны быть представимы строковыми значениями.
    </li>
</ul>
<h4>
    <a name="Topic 2d1" id="Topic 2d1"></a>Простой файл
</h4>
<p>
    Простой файл - это один из простейших методов поддержки постоянной информации о состоянии. &nbsp; При инициализации
    читается простой файл для установки начальных значений состояния. &nbsp; Каждый раз, когда состояние меняется, файл
    переписывается для сохранения нового состояния. &nbsp; Некоторые недостатки применения простого файла для управления
    информацией о состоянии приложения состоят в следующем:
</p>
<ul>
    <li>
        Оказывается неблагоприятное воздействие на масштабируемость приложения, потому что приложение должно блокировать
        объект приложения для предотвращения доступа к глобальным данным, пока переменные состояния изменяются и
        перезаписываются в простой файл.
    </li>
    <li>
        В большинстве случаев, изменение данных потребует перезаписи всего файла.
    </li>
    <li>
        Простые файлы не всегда обеспечивают восстанавливаемость в случае ошибки.
    </li>
</ul>
<h4>
    <a name="Topic 2d2" id="Topic 2d2"></a>XML
</h4>
<p>
    Поддержка постоянной информации о состоянии в файле XML - это следующий шаг после использования простого файла. &nbsp;
    Некоторые преимущества управления состояниями приложения с помощью файла XML по сравнению с использованием простого
    файла состоят с следующем:
</p>
<ul>
    <li>
        Файл XML предоставляет структуру, которая отсутствует в простом файле.
    </li>
    <li>
        Файл XML может быть проанализирован с помощью стандартных API.
    </li>
    <li>
        Файл XML более портативен.
    </li>
</ul>
<h4>
    <a name="Topic 2d3" id="Topic 2d3"></a>База данных
</h4>
<p>
    Поддержка постоянной информации о состояниях с помощью базы данных предоставляет максимальную восстанавливаемость.
    &nbsp; Некоторые преимущества поддержки постоянной информации о состояниях с помощью базы данных состоят в следующем:
</p>
<ul>
    <li>
        Схема таблиц предоставляет структуру.
    </li>
    <li>
        Когда переменная приложения изменена, нет необходимости переписывать всю информацию о состоянии приложения. &nbsp;
        Необходимо переписать только измененную информацию.
    </li>
    <li>
        Непротиворечивость может быть обеспечена координацией восстановления состояния приложения с восстановлением рабочей
        базы данных.
    </li>
    <li>
        Для обеспечения высокой надежности сервер базы данных может быть кластеризован.
    </li>
</ul>
<p>
    Доступ к базам данных может осуществляться с помощью API Java Database Connectivity (JDBC). JDBC можно также
    использовать для доступа к другим табличным источникам данных, включая электронные таблицы и простые файлы.
</p>
<h3>
    <a name="J2EE Mechanisms" id="J2EE Mechanisms"></a>Механизмы, характерные для J2EE
</h3>
<p>
    Платформа J2EE предоставляет определенные механизмы для управления состояниями. Это механизмы самого высокого уровня,
    которые могут быть настроены для использования одного или нескольких основных механизмов, описанных ранее.
</p>
<h4>
    Контекст сервлета
</h4>
<p>
    Сервлеты могут использовать контекст сервлета для сохранения данных, применимых для многих клиентов и клиентских
    сеансов.
</p>
<p>
    Данные, сохраненные в контексте сервлета, являются по существу глобальными переменными для приложения J2EE.&nbsp; В
    результате этого, использование состояния приложения может оказать значительное влияние на проект приложения. &nbsp;
    Разработчик программного обеспечения должен учитывать следующие факторы в процессе выполнения <a href="./../../../core.base_rup/tasks/identify_design_mechanisms_9A197FBC.html" guid="{C7A26BD7-3820-48D9-830F-684C3AF155F9}" class="elementLinkWithUserText">Задача: Определение механизмов проекта</a> для определения, применим ли контекст
    сервлета:
</p>
<ul>
    <li>
        Контекст сервлета может применяться в отдельном процессе, не будучи распределенным по нескольким серверам
        (кластерам).&nbsp; Если это не соответствует потребностям масштабируемости приложения, разработчик должен
        рассматривать сохранение состояния в качестве состояния сеанса. &nbsp;&nbsp;
    </li>
    <li>
        Контекст сервлета - это часть памяти процесса, поэтому он обычно не поддерживается, когда процесс завершен.
    </li>
    <li>
        Несколько нитей могут иметь доступ к глобальным данным. &nbsp; Блокировка и синхронизация глобальных данных могут
        оказать влияние на масштабируемость приложения.
    </li>
</ul>
<h4>
    Объект сеанса HTTP
</h4>
<p>
    Сервлеты и JSP могут сохранять данные, связанные с определенным сеансом клиента в Объекте сеанса HTTP. При сохранении
    данных в объектах сеанса могут возникнуть проблемы при обеспечении доступа к данным сеанса для нескольких серверов.
    Некоторые производители предоставляют возможность перенаправлять клиентские запросы на один сервер, что называется
    "родственность серверов".
</p>
<p>
    Объект сеанса HTTP доступен на сервере в процессе обработки клиентских запросов, но между запросами он либо может быть
    сохранен на сервере, либо нет. Сервер можно настроить для использования любых базовых механизмов хранилища, описанных
    выше, включая сохранение состояния сеанса в cookie на клиенте, в файлах или базе данных на сервере. Он также может
    предоставлять возможность репликации данных сеанса в памяти нескольких серверов.
</p>
<p>
    Сервер настраивается для реализации выбранного механизма - JSP и сервлеты независимо кодируются, получая доступ к
    объекту сеанса с помощью API, указанного в спецификации сервлета.
</p>
<h4>
    Объекты EJB
</h4>
<p>
    Объекты EJB содержат механизмы высокого уровня для сохранения состояния, основанные на механизмах низкого уровня,
    описанных ранее, таких как базы данных и файлы. Объекты сеанса с сохранением состояния используются для сохранения
    данных, связанных с определенным клиентским сеансом, в то время как сущностные объекты JavaBean используются для
    сохранения данных на долгое время. Более подробная информация о сохранении состояний с помощью объектов EJB находится в
    разделе <a href="./../../../tech.j2ee/guidances/guidelines/enterprise_javabean_ejb_7F0C3AFF.html" guid="1.5078998518719443E-305" class="elementLinkWithUserText">Руководство: EJB</a>.
</p>
<h3>
    Проектирование состояния сеанса
</h3>
<p>
    Клиентам Web часто требуется иметь возможность делать множественные запросы браузера при переходе от страницы к
    странице, сохраняя информацию о клиенте, такую как выбранные товары в корзине. Web-приложения управляют этим, создавая
    ИД сеанса и связывая с ним данные о состоянии.
</p>
<p>
    Сам ИД сеанса сохраняется на клиенте с помощью одного или двух механизмов:
</p>
<ul>
    <li>
        cookie - браузер клиента посылает этот cookie&nbsp; на сервер при каждом запросе, позволяя серверу повторно
        установить состояние сеанса.
    </li>
    <li>
        Преобразование URL - URL на страницах, доставленных клиенту сервером, содержат закодированный ИД сеанса. Когда
        пользователь щелкает на таком URL, ИД сеанса посылается на сервер, позволяя серверу повторно установить состояние
        сеанса.
    </li>
</ul>
<p>
    Сервер настраивается для использования выбранного подхода. Сервлеты и JSP должны кодироваться так, чтобы работать
    независимо от настроенного метода. В частности, для кодирования всех URL используйте метод
    HttpServletResponse.encodeURL(). Этот метод проверяет, включено ли преобразование URL, и если да, то выполняет
    кодирование.
</p>
<p>
    Связанные с ИД сеанса данные могут быть сохранены в объекте сеанса HTTP, где к ним могут получить доступ JSP и
    сервлеты, или в объектах JavaBean сеанса.
</p>
<p>
    И для ИД сеанса, и для связанных данных, должен быть установлен тайм-аут, так чтобы данные сеанса, которые не
    используются долгое время, не занимали ресурсов. Разработчик должен выбрать подходящий период тайм-аута.
</p>
<h4>
    <a name="Topic 2b2" id="Topic 2b2"></a>Выбор подходящего механизма
</h4>
<p>
    Разработчики рассматривать процесс сохранения состояния сеанса клиента с точки зрения простоты и быстродействия. Когда
    состояние управляется и сохраняется на клиенте, серверы не должны тратить ресурсов для сохранения информации о
    состоянии или для обеспечения ее непротиворечивости. Недостаток сохранения информации о состоянии на клиенте состоит в
    том, что эта информация должна посылаться на сервер всякий раз, когда она необходима, что вызывает проблемы, связанные
    с задержкой сети. Может возникнуть необходимость рассмотрения моментов, связанных с защитой, если вы хотите скрыть от
    клиента некоторые данные о состоянии сеанса. В этом случае можно применить шифрование.
</p>
<p>
    Если приложение имеет большой объем данных о состоянии сеансов, предпочтительнее сохранять их на сервере, где
    существует меньше ограничений на размер и тип.
</p>
<p>
    В общем случае, состояние сеанса, относящиеся к оформлению, должно сохраняться в объекте сеанса HTTP, а объекты
    JavaBean для сохранения состояния должны содержать информацию, которая необходима для реализации бизнес-логики. Следует
    избегать дублирования данных о состоянии, а вместо этого, перемещать все повторяющиеся данные о состоянии в сеанс HTTP
    и передавать их в JavaBean сеанса как параметры вызова метода JavaBean.
</p>
<p>
    Если данные о сеансе, сохраненные на сервере, должны оставаться неизменными при неполадке узла сервера, тогда нужно
    использовать механизм сохранения и репликации данных сеанса.
</p>
<h3>
    Проектирование длительного сохранения данных о состоянии
</h3>
<p>
    Данные о сеансе сохраняются в течении короткого времени и имеют тайм-аут. Также могут понадобиться данные, сохраняемые
    на долгий период времени.
</p>
<p>
    Подходящий механизм для сохранения таких данных зависит от их вида. Могут применяться cookie, простые файлы, файлы XML
    и базы данных. Для доступа к базе данных обычно применяется сущностный bean-объект. Более подробная информация
    находится в разделе <a href="./../../../tech.j2ee/guidances/guidelines/entity_bean_E721D57E.html" guid="4.528918585369678E-307" class="elementLinkWithUserText">Руководство: Сущностный bean-объект</a>.
</p><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
